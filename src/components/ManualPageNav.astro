---
import { getCollection } from "astro:content";
import {
  parseManualCollectionId,
  getManualPagesByGroup,
  getManualPageUrl,
} from "../utils/manuals";

interface Props {
  id: string;
}

const { id } = Astro.props;
const { group } = parseManualCollectionId(id, true);

const allPages = await getCollection("manualsPages");
const manualPages = getManualPagesByGroup(allPages, group);

const navigationItems = manualPages.map((page) => {
  const parsed = parseManualCollectionId(page.id, true);
  return {
    id: page.id,
    slug: parsed.slug,
    title: parsed.title,
    order: parsed.order,
    orderChapter: parsed.orderChapter,
    chapter: parsed.chapter,
  };
});

const currentIndex = navigationItems.findIndex((item) => item.id === id);
const previousPage =
  currentIndex > 0 ? navigationItems[currentIndex - 1] : null;
const nextPage =
  currentIndex < navigationItems.length - 1
    ? navigationItems[currentIndex + 1]
    : null;

// Generate URLs based on index
const previousUrl = previousPage
  ? getManualPageUrl(group, previousPage.slug, currentIndex - 1 === 0)
  : null;
const nextUrl = nextPage
  ? getManualPageUrl(group, nextPage.slug, currentIndex + 1 === 0)
  : null;
---

{
  (previousPage || nextPage) && (
    <nav class="mx-auto max-w-3xl px-4 py-8" aria-label="Page navigation">
      <div class="flex items-center justify-between gap-4">
        {previousPage && previousUrl && previousPage.title ? (
          <a
            href={previousUrl}
            class="group flex max-w-[calc(45%-1rem)] min-w-0 items-center gap-2 rounded-lg border border-[#333] bg-[#2a2a2a] px-4 py-3 text-[#f2f2f2e6] no-underline transition-all duration-300 hover:border-[#89b29e] hover:bg-[#333] hover:text-[#89b29e]"
          >
            <i class="nf nf-md-chevron_left flex-shrink-0 text-sm transition-transform group-hover:-translate-x-1" />
            <span class="overflow-hidden font-medium text-ellipsis whitespace-nowrap">
              {previousPage.title}
            </span>
          </a>
        ) : (
          <div />
        )}

        {nextPage && nextUrl && nextPage.title ? (
          <a
            href={nextUrl}
            class="group flex max-w-[calc(45%-1rem)] min-w-0 items-center gap-2 rounded-lg border border-[#333] bg-[#2a2a2a] px-4 py-3 text-[#f2f2f2e6] no-underline transition-all duration-300 hover:border-[#89b29e] hover:bg-[#333] hover:text-[#89b29e]"
          >
            <span class="overflow-hidden font-medium text-ellipsis whitespace-nowrap">
              {nextPage.title}
            </span>
            <i class="nf nf-md-chevron_right flex-shrink-0 text-sm transition-transform group-hover:translate-x-1" />
          </a>
        ) : (
          <div />
        )}
      </div>
    </nav>
  )
}

<script is:inline define:vars={{ previousUrl, nextUrl }}>
  document.addEventListener("DOMContentLoaded", function () {
    // Only add keyboard navigation if there are navigation buttons
    if (!previousUrl && !nextUrl) return;

    function handleKeyPress(event) {
      // Only handle arrow keys if no input elements are focused
      if (
        document.activeElement?.tagName === "INPUT" ||
        document.activeElement?.tagName === "TEXTAREA" ||
        document.activeElement?.contentEditable === "true"
      ) {
        return;
      }

      switch (event.key) {
        case "ArrowLeft":
          if (previousUrl) {
            event.preventDefault();
            window.location.href = previousUrl;
          }
          break;
        case "ArrowRight":
          if (nextUrl) {
            event.preventDefault();
            window.location.href = nextUrl;
          }
          break;
      }
    }

    document.addEventListener("keydown", handleKeyPress);

    // Clean up event listener when component unmounts
    return () => {
      document.removeEventListener("keydown", handleKeyPress);
    };
  });
</script>
